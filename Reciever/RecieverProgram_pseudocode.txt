RecieverProgram - Pseudocode

Prerequisites:
- Files expected in Reciever/ before running:
  - Reciever/YPrivate.key   (receiver Y's RSA private key, PKCS#8 DER or PEM)
  - Reciever/symmetric.key  (shared AES key between X and Y; raw 16/24/32 bytes, or hex/base64 text)
  - Reciever/message.rsacipher (RSA ciphertext produced by the sender)
- Output files produced in Reciever/: message.add-msg (decrypted), message.dd (raw digest)

High-level goal:
RSA-decrypt the sender's ciphertext into (AES(Kxy, SHA256(M)) || M), decrypt the AES-encrypted digest, compute SHA-256 over the received M, then compare digests and report integrity.

PSEUDOCODE:
1) Read AES key Kxy from "Reciever/symmetric.key"
   - If file length is 16|24|32 bytes: treat as raw AES key
   - Else if content is hex string: decode hex to bytes
   - Else if content is PEM/base64: base64-decode to bytes
   - Validate final key length is 16/24/32 bytes else error

2) Read RSA private key YPriv from "Reciever/YPrivate.key"
   - Accept PKCS#8 DER bytes or PEM-wrapped (-----BEGIN PRIVATE KEY-----)
   - Convert to PrivateKey object (RSA)

3) RSA-decrypt "Reciever/message.rsacipher" into "Reciever/message.add-msg":
   - Determine RSA block size in bytes: KEY_BYTES = (modulusBitLength + 7) // 8
     - If you cannot determine modulus, you may try a sensible default (e.g., 128 for 1024-bit RSA)
   - For RSA/ECB/PKCS1Padding the ciphertext block size is KEY_BYTES
   - Open message.rsacipher for binary read
   - Open message.add-msg for binary write (truncate/create)
   - Loop: read KEY_BYTES bytes from message.rsacipher
       - If bytesRead < KEY_BYTES: copy to a new array sized bytesRead
       - DEC_BLOCK = RSA_decrypt_PKCS1(YPriv, readBytes)
       - Write DEC_BLOCK to message.add-msg
   - Close files

4) Parse decrypted "message.add-msg":
   - Open message.add-msg for binary read
   - Read first 32 bytes: AES_CIPHER_DIGEST (this is AES(Kxy, SHA256(M)))
       - NOTE: sender used AES/ECB/NoPadding; AES_CIPHER_DIGEST length is 32 bytes (2 AES blocks)
       - If you read fewer than 32 bytes, treat as error

5) AES-decrypt AES_CIPHER_DIGEST using Kxy (AES/ECB/NoPadding)
   - AES_DECRYPTED_DIGEST = AES_decrypt_no_padding(Kxy, AES_CIPHER_DIGEST)
   - Save AES_DECRYPTED_DIGEST (raw 32 bytes) to "Reciever/message.dd"
   - Print hex(AES_DECRYPTED_DIGEST)

6) Compute SHA-256(DIRECTLY) over the rest of message.add-msg (the original M), streaming
   - Create SHA-256 MessageDigest
   - Read remaining bytes from message.add-msg in chunks (e.g., 32KB) and update digest
   - After EOF: COMPUTED_DIGEST = digest.digest()
   - Print hex(COMPUTED_DIGEST)

7) Compare DIGESTS
   - If Arrays.equals(AES_DECRYPTED_DIGEST, COMPUTED_DIGEST): report "DIGESTS MATCH"
   - Else: report "DIGESTS DIFFER"

Notes, edge-cases and important details:
- RSA block size calculation is critical: ciphertext blocks must be read in exact RSA-encrypted block sizes.
  - Ciphertext block size = key modulus byte-length, e.g., 128 for 1024-bit, 256 for 2048-bit.
  - Plaintext block size (before RSA encryption) used by sender was (keyBytes - 11) when using PKCS#1 v1.5.
- AES/ECB/NoPadding used: AES_CIPHER_DIGEST length must be a multiple of 16. SHA-256 = 32 bytes so the sender's approach yields exactly 32 bytes of AES ciphertext.
- Key formats supported: raw DER, PEM-wrapped, base64 text. Receiver expects PKCS#8 private key bytes for Java's PKCS8EncodedKeySpec; adapt if your key uses PKCS#1.
- The receiver currently writes a plaintext file `message.add-msg`. If you prefer not to persist plaintext, decrypt into memory and stream-process.

Commands (compile/run) - PowerShell examples:
- Compile:
  javac -d Reciever Reciever/RecieverProgram.java
- Run receiver (after copying message.rsacipher into Reciever/):
  java -cp Reciever RecieverProgram

Re-implementation tips (language-agnostic):
- Use streaming I/O for RSA decryption and hashing to support large messages.
- Carefully handle partial final RSA blocks when reading ciphertext (read by KEY_BYTES boundaries).
- Validate key lengths and formats at startup with clear error messages.

End of pseudocode
